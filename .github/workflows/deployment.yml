name: Deploy the development blog

on: [push]

permissions:
  id-token: write
  contents: read

jobs:
  deploy:
    name: Deploy development site
    runs-on: ubuntu-latest
    steps:
      - name: Git Checkout
        uses: actions/checkout@v3

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v1.7.0
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOYMENT_ARN }}
          role-session-name: GitHub_to_AWS_via_FederatedOIDC
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.7

      # We deal with wrangler ourselves as it's quicker to just do a global
      # install here than use the wrangler github action
      - name: Install Cloudflare Wrangler
        run: |
          npm install -g wrangler@latest

      - name: Run Terraform
        id: tf_run
        env:
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        working-directory: iac/terraform
        run: |
          cat > backend.conf << EOF
          bucket = "${{ secrets.TFSTATE_BUCKET }}"
          key    = "dev-site.tfstate"
          region = "${{ secrets.AWS_REGION }}"
          EOF

          terraform init -input=false -backend-config=./backend.conf

          terraform apply -no-color -auto-approve
          echo "tf_output_json=$(terraform-bin output -json -no-color | jq -c)" >> $GITHUB_OUTPUT

      - name: Build NextJS Site
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
        working-directory: site
        run: |
          npm ci
          npm run test:ci
          npm run pages:build
          project_name=$(echo '${{ steps.tf_run.outputs.tf_output_json }}' | jq -r '.cloudflare_pages_nextjs_project_name.value')
          # Need --commit-dirty=true as we auto-generate some code not in git
          wrangler pages deploy ./.vercel/output/static --project-name ${project_name} --commit-dirty=true
